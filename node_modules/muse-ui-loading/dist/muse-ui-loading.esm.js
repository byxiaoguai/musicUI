/* muse-ui-loading myron.liu version 0.2.0 */
import color from 'muse-ui/lib/internal/mixins/color';
import Vue from 'vue';

var config = {
  overlayColor: 'hsla(0,0%,100%,.9)',
  size: 48,
  color: 'primary',
  className: ''
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var loadingOpt = {
  mixins: [color],
  name: 'mu-loading',
  props: {
    size: Number,
    overlayColor: String,
    text: String,
    fixed: Boolean,
    className: String
  },
  data: function data() {
    return {
      show: false
    };
  },
  render: function render(h) {
    var _class;

    return h('mu-fade-transition', [h('div', {
      staticClass: 'mu-loading-wrap',
      class: (_class = {}, defineProperty(_class, this.className || '', true), defineProperty(_class, 'mu-loading-wrap__fixed', this.fixed), _class),
      style: {
        'background-color': this.overlayColor
      },
      directives: [{
        name: 'show',
        value: this.show
      }]
    }, [h('mu-circular-progress', {
      staticClass: 'mu-loading-circular',
      props: {
        size: this.size,
        color: this.color,
        strokeWidth: 2
      }
    }), this.text ? h('span', {
      staticClass: 'mu-loading-text ' + this.getNormalColorClass(this.color, true),
      style: {
        color: this.color
      }
    }, this.text) : undefined])]);
  }
};

var LoadingConstructor = Vue.extend(loadingOpt);
var isServer = typeof window === 'undefined';
var Loading = function Loading() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (isServer) return;
  var target = options.target && typeof options.target.appendChild === 'function' ? options.target : document.body;
  if (target._isLoading) return;

  var loading = new LoadingConstructor({
    el: document.createElement('div'),
    propsData: _extends({}, config, {
      fixed: !options.target
    }, options)
  });

  target.appendChild(loading.$el);
  target._isLoading = true;
  loading.show = true;
  return {
    instance: loading,
    close: function close() {
      if (!loading) return;
      loading.show = false;
      this.instance && (this.instance = null);
      setTimeout(function () {
        loading.$el.parentNode && loading.$el.parentNode.removeChild(loading.$el);
        loading.$destroy();
        loading = null;
        target._isLoading = false;
      }, 500);
    }
  };
};

function toggleLoading(el, isLoading) {
  if (isLoading) {
    var options = {
      target: el
    };
    el.hasAttribute('data-mu-loading-color') && (options.color = el.getAttribute('data-mu-loading-color'));
    el.hasAttribute('data-mu-loading-overlay-color') && (options.overlayColor = el.getAttribute('data-mu-loading-overlay-color'));
    el.hasAttribute('data-mu-loading-text') && (options.text = el.getAttribute('data-mu-loading-text'));
    el.hasAttribute('data-mu-loading-size') && (options.size = Number(el.getAttribute('data-mu-loading-size') || config.size));
    el.hasAttribute('data-mu-loading-class') && (options.className = el.getAttribute('data-mu-loading-class'));
    el._loading = Loading(options);
  } else {
    if (el._loading) {
      el._loading.close();
      el._loading = null;
    }  }
}

var directive = {
  name: 'loading',
  inserted: function inserted(el, _ref) {
    var value = _ref.value;

    toggleLoading(el, value);
  },
  update: function update(el, _ref2) {
    var value = _ref2.value;

    if (el._loading) {
      !value && toggleLoading(el, false);
    } else {
      value && toggleLoading(el, true);
    }
  },
  unbind: function unbind(el, binding) {
    if (el._loading) el._loading.close();
  }
};

Loading.config = function (options) {
  if (!options || Array.isArray(options) || (typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') return config;
  for (var key in options) {
    if (!options.hasOwnProperty(key)) continue;
    config[key] = options[key];
  }
  return config;
};

Loading.install = function (Vue$$1, options) {
  Loading.config(options);
  Vue$$1.prototype.$loading = Loading;
  Vue$$1.directive(directive.name, directive);
};

export default Loading;
